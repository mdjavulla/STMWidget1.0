import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.core.io.ClassPathResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

@SpringBootApplication
public class UpdateServerApplication {

    private static Map<String, byte[]> updateFiles = new HashMap<>();
    private static String currentVersion = "1.0"; // Initial version

    public static void main(String[] args) {
        SpringApplication.run(UpdateServerApplication.class, args);
    }

    @RestController
    static class UpdateController {

        @GetMapping("/update")
        public ResponseEntity<byte[]> getUpdate() throws IOException {
            byte[] fileBytes = updateFiles.get(currentVersion);
            if (fileBytes != null) {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
                headers.setContentDispositionFormData("attachment", "update.zip");
                return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);
            } else {
                return ResponseEntity.notFound().build();
            }
        }

        @PostMapping("/update")
        public ResponseEntity<String> receiveUpdate(@RequestBody UpdateRequest request) {
            if (isNewerVersion(request.getVersion(), currentVersion)) {
                updateFiles.put(request.getVersion(), Base64.getDecoder().decode(request.getUpdateFile()));
                currentVersion = request.getVersion();
                return ResponseEntity.ok("Update received successfully for version: " + request.getVersion());
            } else {
                return ResponseEntity.badRequest().body("Provided version is not newer than the current version");
            }
        }

        private boolean isNewerVersion(String newVersion, String currentVersion) {
            // Custom version comparison logic - assuming version format like "1.0", "1.1", etc.
            String[] newVersionParts = newVersion.split("\\.");
            String[] currentVersionParts = currentVersion.split("\\.");
            for (int i = 0; i < Math.min(newVersionParts.length, currentVersionParts.length); i++) {
                int newPart = Integer.parseInt(newVersionParts[i]);
                int currentPart = Integer.parseInt(currentVersionParts[i]);
                if (newPart > currentPart) {
                    return true;
                } else if (newPart < currentPart) {
                    return false;
                }
            }
            return newVersionParts.length > currentVersionParts.length;
        }
    }

    static class UpdateRequest {
        private String version;
        private String updateFile; // Base64 encoded update file content

        // Getters and setters

        public String getVersion() {
            return version;
        }

        public void setVersion(String version) {
            this.version = version;
        }

        public String getUpdateFile() {
            return updateFile;
        }

        public void setUpdateFile(String updateFile) {
            this.updateFile = updateFile;
        }
    }
}


The UpdateController class defines two endpoints:

GET /update: This endpoint serves the update file (update.zip) to the Electron application.
POST /update: This endpoint receives update requests from the Electron application along with the version number and update file content.
The getUpdate method serves the update.zip file located in the classpath. It reads the file as bytes and constructs an HTTP response with the appropriate headers to trigger a download in the Electron application.

The receiveUpdate method processes the update request received via POST. In this example, it simply returns a success message along with the version number.

The UpdateRequest class represents the JSON payload expected in the POST request. It contains fields for the version number and base64 encoded update file content.

Make sure you have the update.zip file in the classpath, or you can adjust the UPDATE_FILE_PATH constant to point to the correct location of your update file.

In this updated code:

The updateFiles map holds update files for different versions.
The currentVersion variable keeps track of the current version.
The isNewerVersion method compares versions based on the assumption that versions are in the format "1.0", "1.1", etc. You can adjust this logic based on your versioning scheme.
When receiving an update request (POST /update), the application checks if the provided version is newer. If it is, the update file is saved, and the current version is updated.

Electron code to auto-update:
// Initialize auto-updater
function initAutoUpdater() {
  // Set the URL for the update feed (your development server)
  autoUpdater.setFeedURL({
    url: 'https://your-development-server.com/update', // Replace with your development server URL
    serverType: 'json' // Set to 'json' if your server provides updates in JSON format
  });

  // Check for updates
  autoUpdater.checkForUpdatesAndNotify();
}

// IPC event for getting app version
ipcMain.on('app_version', (event) => {
  event.sender.send('app_version', { version: app.getVersion() });
});

// Handle auto-update events
autoUpdater.on('update-available', () => {
  // Notify user that an update is available
  dialog.showMessageBox({
    type: 'info',
    title: 'Update Available',
    message: 'A new version of the application is available. Downloading now...',
    buttons: ['OK']
  });
});

autoUpdater.on('update-downloaded', () => {
  // Prompt the user to install the downloaded update
  dialog.showMessageBox({
    type: 'info',
    title: 'Update Downloaded',
    message: 'The update has been downloaded. Do you want to install it now?',
    buttons: ['Install', 'Later']
  }).then((result) => {
    if (result.response === 0) {
      // Quit and install update
      autoUpdater.quitAndInstall();
    }
  });
});

// Handle auto-update errors
autoUpdater.on('error', (error) => {
  console.error('Auto-update error:', error.message);
});

Explanation:
Electron auto-updater code appears to be correctly configured to interact with the Spring Boot server API for downloading updates based on version comparison. Here's a breakdown of how it works:

Initialization (initAutoUpdater function): This function initializes the auto-updater and sets the feed URL to your development server where the update server API is hosted (https://your-development-server.com/update). It specifies that the server provides updates in JSON format.

Checking for Updates (autoUpdater.checkForUpdatesAndNotify): This function checks for updates from the server and notifies the user if an update is available.

IPC Event for App Version (ipcMain.on('app_version', ...): This event handler listens for an IPC event called 'app_version' and sends back the current version of the Electron application.

Handling Update Events (autoUpdater.on('update-available', ...), autoUpdater.on('update-downloaded', ...), autoUpdater.on('error', ...)): These event listeners handle different stages of the update process:

'update-available': Notifies the user that an update is available.
'update-downloaded': Prompts the user to install the downloaded update and performs the installation if the user agrees.
'error': Handles any errors that occur during the update process and logs them to the console.
